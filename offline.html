<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="See a live demonstration of Archivium's website deployment tool, featuring advanced cache policy management. Learn how to optimize your website's performance and improve user experience." />
    <title>Unbust Offline demo (_VERSION_)</title>
    <link rel="stylesheet" href="_STYLES_FILE_">
</head>
<body>
    <h1>Unbust Offline demo (release <span class="code">_VERSION_</span>)</h1>
    <div class="byline"><p>Cache mode: <span class="code">_CACHE_POLICY_</span></p></div>
    <div class="progress-bar">
        <div class="progress" id="progress"></div>
        <span class="label" id="freshness">Remaining Support (click to disable auto-reload)</span>
    </div>
    <div class="text-box">
        <p>This page was pre-fetched along with its image when the main page was loaded, so it could be pre-cached. This is a trick done to demonstrate that cached content is available offline, which is not typical of websites. Unbust Cache sets the caching headers specifically to allow static content to be available offline.</p>
        <img src="/books.png" width="300" height="300">

        <p>The other two demos demonstrate more typical setups, where caching does not accomodate offline use because it requires the browser to re-validate the entry point on navigation.</p>
        <p>See <a href="https://cloudflare-tests.pages.dev" target="_blank">typical cache demo</a> and <a href="https://accelerated.cloudflare-tests.pages.dev" target="_blank">accellerated cache demo</a> as examples.</p>
    </div>
    <div id="online-status-bar" class="online-status-bar">
        <span id="online-status-text">You are currently offline</span>
    </div>    
    <script>
		const utcDateElements = document.querySelectorAll('.udate');

		utcDateElements.forEach((element) => {
			const utcDate = new Date(element.innerText);
			const localDate = utcDate.toLocaleString();
			element.innerText = localDate;
		});

        const localTzElements = document.querySelectorAll('.localtz');

        // Get the local timezone name
		const localTzName = Intl.DateTimeFormat().resolvedOptions().timeZone;

        localTzElements.forEach((element) => {
            element.innerText = localTzName;
        });

        let guaranteedFresh = true;
        let supportBar = document.querySelector(".progress");

        function setReloading(e, reload) {
            const freshness = document.getElementById("freshness");
            if (reload) {
                freshness.innerText = "Remaining Support, out of _SUPPORT_TIME_ days (auto-reload)";
                supportBar.classList.remove("no-reload");
            } else {
                freshness.innerText = "Remaining Support, out of _SUPPORT_TIME_ days (no auto-reload)";
                supportBar.classList.add("no-reload");
            }
            guaranteedFresh = reload;
        }

        const MAX_INT32 = 2 ** 31 - 1; // 2147483647 (hex 0x7FFFFFFF)

        function runAt(func, date) {
            const now = Date.now();
            const then = date.valueOf();
            const diff = Math.max(then - now, 0);
            if (diff > MAX_INT32) {
                setTimeout(() => {
                    runAt(func, date);
                }, MAX_INT32);
            } else {
                setTimeout(func, diff);
            }
        }

        function initSupportBar() {
            const deployed = new Date("_DEPLOYED_TIME_").getTime() / 1000;
            const endSupport = deployed + _SUPPORT_TIME_ * 86400;
            var remainingSupport = endSupport - Math.floor(Date.now() / 1000);
            /* If there was no update by the end support, it is overdue, ie, 0 remaining support commitment */
            remainingSupport = Math.max(0, remainingSupport);
            /* At any point in time, the minimum support is the cache time */
            remainingSupport = Math.max(remainingSupport, _ENTRY_CACHE_TIME_);

            supportBar.style.width = `${remainingSupport / (endSupport - deployed) * 100}%`;

            if (remainingSupport === 0) {
                setReloading(document.querySelector(".progress-bar"), false);
            }
            supportBar.classList.add("progress-animated");
            supportBar.style.animationDuration = `${remainingSupport}s`;

            runAt(function() {
                if (guaranteedFresh && navigator.onLine) {
                    window.location.reload();
                }
            }, (remainingSupport * 1000.0 + Date.now()));
        }

        initSupportBar();
        document.querySelector(".progress-bar").addEventListener("click", function(event) {
            setReloading(event.target, !guaranteedFresh);
        });

        /* Online / offline indicator at the bottom of the page */
        const onlineStatusBar = document.getElementById('online-status-bar');
        // const onlineStatusText = document.getElementById('online-status-text');

        function updateOnlineStatus() {
        if (navigator.onLine) {
            onlineStatusBar.classList.add('online');
        } else {
            onlineStatusBar.classList.remove('online');
            // onlineStatusText.textContent = 'You are currently offline.';
        }
        }

        window.addEventListener('online', updateOnlineStatus);
        window.addEventListener('offline', updateOnlineStatus);

        updateOnlineStatus(); // initial check        
	</script></body>
</html>